车牌定位程序说明
===

## 程序功能简介
该程序提供两种车牌定位模式，实现车牌定位后能提取出的车牌保存为新图片。建议两种模式都尝试。


## 算法简介
此处提供两种车牌定位算法，一是基于蓝色的颜色分割，二是基于轮廓的纹理识别。

前一种方法只适用于蓝色车牌，对于蓝色车牌的识别率较好。后一种方法适用于所有车牌，适用范围广。下面进行简要说明。

### 基于蓝色的颜色分割
该算法利用了蓝色车牌的颜色信息。流程是先将RGB转换为HSV，根据蓝色车牌的大致HSV范围对图片二值化，再高斯模糊去噪，而后对图片进行膨胀腐蚀处理，形成车牌闭区域，由Sobel边缘检测算法留下边缘，通过寻找连通域实现最终车牌定位。

主要函数功能说明：
```cpp
Image* imgHSV = Rgb2Hsv(img);			//转换为HSV
Image* imgPlate = PlateFilter(imgHSV);		//二值化，符合蓝色车牌的HSV区域置为白色
Gaussian(imgPlate);				//高斯去噪
for (int i = 0; i < 4; i++)
{
	Dilation(imgPlate, 0);			//水平膨胀
	Dilation(imgPlate, 1);			//垂直膨胀
}
Erosion(imgPlate, 1);				//垂直腐蚀
Sobel(imgPlate);				//Sobel边缘检测
EdgeErasion(imgPlate, 10);			//去除图片四周10个像素点的白色
CRect* plateRectAll = find_connected_region_location(imgPlate, 90, 30, 2.3, 3.7);		//寻找符合车牌宽高比的连通域位置
```
### 基于轮廓的纹理识别
该算法利用了车牌竖向纹理丰富的特征。流程是先将RGB转换为灰度图，由Sobel边缘检测算子提取边缘，再中值滤波去噪后二值化，而后膨胀腐蚀形成闭区域，再提取闭区域的边缘，通过寻找连通域最后实现车牌定位。

主要函数功能说明：
```cpp
Image* imgGray = Rgb2Gray(img);			//转换为灰度图
Sobel(imgGray);					//Sobel边缘检测
medianFilter(imgGray);				//中值滤波
thresholdSet(imgGray, 150);			//二值化，将灰度值大于150的置为白色
for (int i = 0; i < 3; i++)
{
	Dilation(imgGray, 0);			//水平膨胀
}
Erosion(imgGray, 1);				//垂直腐蚀
Sobel(imgGray);					//再次Sobel边缘检测
EdgeErasion(imgPlate, 10);			//去除图片四周10个像素点的白色
CRect* plateRectAll = find_connected_region_location(imgGray, 90, 30, 2.3, 3.7);    //寻找符合车牌宽高比的连通域位置
```

## 可执行程序流程
首先选择处理方法（1或2），再输入测试图片路径，回车后可显示处理bmp的信息头信息，之后会看到处理过程的中间图片被保存，region_num表示找到的车牌区域数，若不为零则保存找到的区域为新图片。

<i>注意事项：该程序把识别车牌的最小宽度设定为90像素，最小高度为30像素，所以图中车牌大小至少比这个数值大！</i>

## 测试结果
第一种和第二种方法的图片测试结果分别存放在【测试结果】文件夹，测试图片为elearning上提供的调试图片，以及自寻的一张黄色车身黄色车牌的图片（6.bmp）。
子文件夹如【1_0.847】的命名含义是“图片序号+本机测试所用时间”，时间由于测试机器的不同稍有差异。

第一种方法成功挖出所有蓝色车牌，可见它的优点是对蓝色车牌辨认度较高，但缺点是无法适用于所有车牌。

第二种方法可以定位所有颜色车牌，可见它的优点是其通用性，但有时会误识别某些区域，缺点在于需要后续手动选择正确的图片。


## 其他备注
由于测试期间换过很多算法，所以源文件里有一些未用到但已写完的函数，但没舍得移除……不用在意就好
